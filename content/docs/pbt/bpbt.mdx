---
title: BobuPBT (BPBT)
description: Implementing PBTs for the Sake and a Dream gallery exhibition.
---

> "Sake and a Dream" was a gallery exhibition featuring Bobu, held on Friday, September 12th, 2025 at Zepster Gallery in Brooklyn.
>
> Proposed and organized by [•ᴅɢᴛʟ•](https://x.com/dgtlemissions). This code was written by [Bobu Devinson](https://x.com/bobudev).

This repository serves as a reference of one way to approach implementing Chiru Lab's [Physical Backed Token (PBT)](https://www.pbt.io/) and is the code used for minting, transferring, and displaying PBTs on [Sake and a Dream](https://www.sakeandadream.com/).

It uses:

- [Foundry](https://getfoundry.sh/) for contract development
- [Next.js](https://nextjs.org/) 16 as the web application
- [Vercel](https://vercel.com/) as the hosting provider
- [AnimeChain](https://www.anime.xyz/) as the target blockchain

This is purposely long to be more helpful to less experienced developers. If you are an experienced developer, feel free to go straight to the code.

## Prerequisites

1. Skimmed [@chiru-labs/pbt's README.md](https://github.com/chiru-labs/PBT)
2. Some experience with Solidity and React
3. [Arx HaLo chips](https://arx.org/)

## Goals

1. Simplify the user experience (UX) by removing any step that wasn't necessary
2. Simplify the developer experience (DX) by leveraging Next.js features

## Background

The original implementation had a few limitations in 2022:

1. MetaMask's mobile browser (the popular choice at the time) didn't have support for the Web Authentication API[^1]
2. The chip provider was at its earliest stage and hadn't made a client library yet

Unfortunately, this led to complicated UX/DX for minting and transfers to accomodate:

1. User visits the website on desktop
2. User connects their wallet
3. User presses a button to start the minting process
4. The website generates a QR code for the user to scan with their phone
5. User is directed to the mobile version of the website
6. The desktop version of the website begins polling for the signature that will generated by scanning the PBT
7. User scans the PBT and writes the signature to the backend
8. The desktop version of the website gets the signature
9. User proceeds with the minting process

## Developing an updated approach

Several things have changed since:

1. Modern wallet connectors are available on mobile
2. There are embedded wallets like [Privy](https://www.privy.io/) and [Alchemy's Smart Wallets](https://www.alchemy.com/smart-wallets) and enable features like sponsored gas transactions. This ends our reliance on Metamask's mobile browser
3. We can now use `@arx-research/libhalo` and their officially supported API
4. Modern web frameworks like [Vercel](https://vercel.com/)'s [Next.js](https://nextjs.org/) support server-side functions

What the UX can look like now:

1. User visits the website
2. User can connect their wallet or signs in with their preferred social provider to create a wallet
3. User scans to mint their PBT
4. User proceeds with the minting process

The DX:

1. A single Next.js application using `@arx-research/libhalo`
2. Set up authentication with an embedded wallet service that provides gas sponsorship or setup a modern wallet connector

No desktop to mobile roundtrip for the user, no polling, and no QR codes.

Interestingly, we can take it further.

**PBTs are scan-to-own.** If a person is able to scan it, we can safely assume they own it. We don't need to integrate embedded wallets or even have the user sign in.

As far as we're concerned, we only need a destination address and to pay for the transaction.

Our UX:

1. User visits the website on their phone
2. User pastes their preferred destination wallet address
3. Users scans to mint or transfer their PBT

Our DX:

1. A single Next.js application using `@arx-research/libhalo`
2. A secured Next.js Server Action that fires off the transaction

The user doesn't have to fumble to get their wallet to connect or expose personal information. If something is wrong with the user's phone, a friend or a store clerk can mint it for them.

There rest of the document answers some questions you probably now have, goes over implementation details, and addresses some new problems that come up.

### FAQ

#### Does the PBT contract require special logic for this?

Nope. All ours does is extend `@chiru-labs/v2/PBTSimple.sol`, maps PBTs in the constructor, a function to mint, and a function to set the base URI.

#### What if someone else scans it to send it to a different address?

The owner can scan again and reclaim it.

#### What if it's sent to the burn address?

The PBT contract reverts if the burn address is set at the destination address.

#### What if someone steals the physical chip?

The PBT has a new owner.

## Implementing our approach

### Our requirements

"Sake and a Dream" features about a dozen artists. That means a dozen artworks will be embedded with PBTs to live on Animechain.

- [ ] Purchase enough HaLo chips on [Arx's online store](https://arx.org/)
- [ ] Install [Foundry](https://getfoundry.sh/) for contract development
- [ ] Create a Foundry project `forge init project-name`
- [ ] Install `@chiru-labs/pbt` by running `forge install https://github.com/chiru-labs/PBT`
- [ ] Create a contract that extends `PBTSimple` v2 with a `mint` and `setBaseURI` functions
- [ ] Create a spreadsheet with all the artworks
- [ ] Scan all the PBTs with [Arx's scanner](https://bulk.vrfy.ch/) and export to JSON
- [ ] Assign their ETH addresses to artworks they will be embedded to
- [ ] Rename the JSON export to `pbt.json`. This will be fed into the contract's constructor when the contract is deployed
- [ ] Create a test script for unit tests
- [ ] Create a deploy script for deploying the contract
- [ ] Create a verify script for verifying the deployment
- [ ] Run a local testnet with `anvil` to test the deploy and verify scripts
- [ ] Create a Next.js app with `Tailwind CSS v4`, `shadcn`, `viem` and `@arx-research/libhalo`
- [ ] Create a Form component that takes in a destination address
- [ ] Set up ngrok tunneling and environment variables for the RPC, contract, and sponsor wallet
- [ ] Create a NFC scanning component to handle scanning and debugging
- [ ] Create a Server Action that takes the destination address, signature, and submits a transaction
- [ ] Deploy to remote testnet and Vercel to test
- [ ] Purchase and set up domain
- [ ] Create ERS records by contacting [ers@arx.org](mailto:ers@arx.org)
- [ ] Set up WAF
- [ ] Deploy to mainnet

[^1]: [Issue submitted by Chiru Lab's 2pmflow](https://github.com/MetaMask/metamask-mobile/issues/4974).
